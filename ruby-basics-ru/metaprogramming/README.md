# Метапрограммирование

В Ruby очень много метапрограммирования, встроенного во все части языка. Это значит, что программа может менять свое поведение прямо во время работы практически в любую сторону. На Ruby создано большое количество решений, которые потом распространились по другим языкам. Самым ярким примером является фреймворк Ruby On Rails.

Иногда возникает необходимость создать сущность с определенными свойствами заранее известного типа. Такую задачу помогают решать библиотеки типа [Virtus](https://github.com/solnic/virtus), они позволяют генерировать атрибуты класса на основе схемы.

```ruby
class Post
  include Virtus.model
  attribute :title, String
  attribute :body, String
  attribute :created_at, DateTime
  attribute :published, Boolean
end

post = Post.new title: 'Hello, World!', body: 'First Post'
puts post.title # => 'Hello, World!'
post.title  = 'Goodbye, World!'
puts post.title  # => 'Goodbye, World!'
post.created_at = 'November 18th, 1983'
puts post.created_at # => #<DateTime: 1983-11-18T00:00:00+00:00 (4891313/2,0/1,2299161)>

puts post.attributes # => {:title=>"Goodbye, World!", :body=>"First Post", :created_at=>#<DateTime: 1983-11-18T00:00:00+00:00 ((2445657j,0s,0n),+0s,2299161j)>, :published=>nil}
```

В этом задании мы реализуем аналог такой библиотеки. Может показаться, что такой подход к коду странный или безумный, но на деле в библиотеках Ruby всё может быть еще более хитро.

## Ссылки

* [Monkey patch](https://ru.wikipedia.org/wiki/Monkey_patch)
* [Вникаем в include и extend](https://habr.com/ru/post/143483/)

## Задачи

### lib/model.rb

Реализуйте модуль *Model*, который содержит конструктор и позволяет указывать атрибуты для экземпляров класса и автоматическое преобразование типов.

Модуль *Model* содержит метод `attribute(name, [options = {}])`, который принимает следующие параметры.

* `name` - имя атрибута
* `options` - опции атрибута в виде хеша. Ключ `type` отвечает за тип в который будет преобразовавываться атрибут при получении. Если тип не указан, то атрибут не преобразуется

Когда *Model* подключается в класс, то класс приобретает следующие методы:

* `initialize()` - принимает хеш с атрибутами. Все атрибуты, которые не указаны в схеме - игнорируются. По умолчанию принимает пустой хеш
* `attributes()` - возвращает хеш с преобразованными атрибутами (преобразуются исходя из схемы)

Вызов метода *attribute()* создаёт геттеры и сеттеры атрибута.

* Геттеры и сеттеры атрибутов. Геттеры возвращают преобразованные в нужный тип атрибуты

## Дополнительное задание

Измените Модуль *Model* таким образом, чтобы можно было задавать дефолтное значение для атрибута. Метод должен принимать в опциях атрибута дефолтное значение под ключем `default`, которое возвращается, если значение атрибута не указано. Дефолтное значение для атрибута будет возвращаться также в методе `attributes()`.

### test/user_test.rb

Раскомментируйте тесты, чтобы проверить дополнительное задание.

## Подсказки

* В этом задании вам потребуется использовать метод [define_method](https://apidock.com/ruby/Module/define_method)
